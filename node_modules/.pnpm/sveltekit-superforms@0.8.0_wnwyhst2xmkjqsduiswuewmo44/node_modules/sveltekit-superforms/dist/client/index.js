import { enhance, applyAction } from '$app/forms';
import { beforeNavigate, invalidateAll } from '$app/navigation';
import { page } from '$app/stores';
import { isElementInViewport, scrollToAndCenter } from './elements.js';
import { derived, get, writable } from 'svelte/store';
import { onDestroy, tick } from 'svelte';
import { browser } from '$app/environment';
import { SuperFormError } from '../index.js';
import { stringify } from 'devalue';
import { mapErrors, traversePath, findErrors, traversePathsAsync, comparePaths, setPaths, pathExists } from '../entity.js';
import { fieldProxy } from './proxies.js';
import { clone } from '../utils.js';
var FetchStatus;
(function (FetchStatus) {
    FetchStatus[FetchStatus["Idle"] = 0] = "Idle";
    FetchStatus[FetchStatus["Submitting"] = 1] = "Submitting";
    FetchStatus[FetchStatus["Delayed"] = 2] = "Delayed";
    FetchStatus[FetchStatus["Timeout"] = 3] = "Timeout";
})(FetchStatus || (FetchStatus = {}));
export { jsonProxy, intProxy, numberProxy, booleanProxy, dateProxy, fieldProxy, formFieldProxy } from './proxies.js';
export { superValidate, actionResult, message, setMessage, setError, defaultData } from '../validate.js';
const defaultFormOptions = {
    applyAction: true,
    invalidateAll: true,
    resetForm: false,
    autoFocusOnError: 'detect',
    scrollToError: 'smooth',
    errorSelector: '[data-invalid]',
    selectErrorText: false,
    stickyNavbar: undefined,
    taintedMessage: 'Do you want to leave this page? Changes you made may not be saved.',
    onSubmit: undefined,
    onResult: undefined,
    onUpdate: undefined,
    onUpdated: undefined,
    onError: (event) => {
        console.warn('Unhandled Superform error, use onError event to handle it:', event.result.error);
    },
    dataType: 'form',
    validators: undefined,
    defaultValidator: 'keep',
    clearOnSubmit: 'errors-and-message',
    delayMs: 500,
    timeoutMs: 8000,
    multipleSubmits: 'prevent',
    validation: undefined,
    SPA: undefined,
    validateMethod: 'auto'
};
/**
 * Initializes a SvelteKit form, for convenient handling of values, errors and sumbitting data.
 * @param {Validation} form Usually data.form from PageData.
 * @param {FormOptions} options Configuration for the form.
 * @returns {SuperForm} An object with properties for the form.
 */
export function superForm(form, options = {}) {
    options = { ...defaultFormOptions, ...options };
    function emptyForm(data = {}) {
        return {
            valid: false,
            errors: {},
            data,
            empty: true,
            constraints: {}
        };
    }
    function findForms(data) {
        return Object.values(data).filter((v) => isValidationObject(v) !== false);
    }
    /**
     * Return false if object isn't a validation object, otherwise the form id,
     * which may be undefined, so a falsy check isn't enough.
     */
    function isValidationObject(object) {
        if (!object || typeof object !== 'object')
            return false;
        if (!('valid' in object &&
            'empty' in object &&
            typeof object.valid === 'boolean')) {
            return false;
        }
        return 'id' in object && typeof object.id === 'string'
            ? object.id
            : undefined;
    }
    if (typeof form === 'string' && typeof options.id === 'string') {
        throw new SuperFormError('You cannot specify an id both in the first superForm argument and in the options.');
    }
    const unsubscriptions = [];
    onDestroy(() => {
        unsubscriptions.forEach((unsub) => unsub());
        for (const events of Object.values(formEvents)) {
            events.length = 0;
        }
    });
    let formId = typeof form === 'string' ? form : options.id ?? form?.id;
    const FormId = writable(formId);
    unsubscriptions.push(FormId.subscribe((id) => (formId = id)));
    // Detect if a form is posted without JavaScript.
    {
        const postedForm = get(page).form;
        if (postedForm && typeof postedForm === 'object') {
            for (const superForm of findForms(postedForm).reverse()) {
                if (superForm.id === formId) {
                    form = superForm;
                    break;
                }
            }
        }
    }
    // Check for nested objects, throw if datatype isn't json
    function checkJson(key, value) {
        if (!value || typeof value !== 'object')
            return;
        if (Array.isArray(value)) {
            if (value.length > 0)
                checkJson(key, value[0]);
        }
        else if (!(value instanceof Date)) {
            throw new SuperFormError(`Object found in form field "${key}". Set options.dataType = 'json' and use:enhance to use nested data structures.`);
        }
    }
    // Normalize form argument to Validation<T, M>
    if (!form || typeof form === 'string') {
        form = emptyForm(); // Takes care of null | undefined | string
    }
    else if (isValidationObject(form) === false) {
        form = emptyForm(form); // Takes care of Partial<z.infer<T>>
    }
    const form2 = form;
    if (options.dataType !== 'json') {
        for (const [key, value] of Object.entries(form2.data)) {
            checkJson(key, value);
        }
    }
    // Need to clone the validation data, in case
    // it's used to populate multiple forms.
    const initialForm = clone(form2);
    const storeForm = clone(form2);
    // Stores for the properties of Validation<T, M>
    const Valid = writable(storeForm.valid);
    const Empty = writable(storeForm.empty);
    const Message = writable(storeForm.message);
    const Errors = writable(storeForm.errors);
    const Constraints = writable(storeForm.constraints);
    const Meta = writable(storeForm.meta);
    let taintedFormState = clone(initialForm.data);
    const _formData = writable(storeForm.data);
    const Form = {
        subscribe: _formData.subscribe,
        set: (value, options = {}) => {
            checkTainted(value, taintedFormState, options.taint ?? true);
            taintedFormState = clone(value);
            return _formData.set(value);
        },
        update: (updater, options = {}) => {
            return _formData.update((value) => {
                const output = updater(value);
                checkTainted(output, taintedFormState, options.taint ?? true);
                taintedFormState = clone(value);
                return output;
            });
        }
    };
    const LastChanges = writable([]);
    function checkTainted(newObj, compareAgainst, options) {
        if (options === false) {
            return;
        }
        else if (options === 'untaint-all') {
            Tainted.set(undefined);
            return;
        }
        const paths = comparePaths(newObj, compareAgainst);
        if (options === true) {
            LastChanges.set(paths);
        }
        if (paths.length) {
            Tainted.update((tainted) => {
                //console.log('Update tainted:', paths, newObj, compareAgainst);
                if (!tainted)
                    tainted = {};
                setPaths(tainted, paths, options === true ? true : undefined);
                return tainted;
            });
        }
    }
    const Tainted = writable();
    // Timers
    const Submitting = writable(false);
    const Delayed = writable(false);
    const Timeout = writable(false);
    // Utilities
    const AllErrors = derived(Errors, ($errors) => {
        if (!$errors)
            return [];
        return findErrors($errors);
    });
    const FirstError = derived(AllErrors, ($all) => $all[0] ?? null);
    //////////////////////////////////////////////////////////////////////
    if (typeof initialForm.valid !== 'boolean') {
        throw new SuperFormError('A non-validation object was passed to superForm. ' +
            "Check what's passed to its first parameter (null/undefined is allowed).");
    }
    if (options.SPA && options.validators === undefined) {
        console.warn('No validators set for Superform in SPA mode. Add them to the validators option, or set it to false to disable this warning.');
    }
    // Need to set this after use:enhance has run, to avoid showing the
    // tainted dialog when a form doesn't use it or the browser doesn't use JS.
    const _taintedMessage = options.taintedMessage;
    options.taintedMessage = undefined;
    function enableTaintedMessage() {
        options.taintedMessage = _taintedMessage;
    }
    function rebind(form, untaint, message) {
        if (untaint) {
            Tainted.set(typeof untaint === 'boolean' ? undefined : untaint);
            taintedFormState = clone(form.data);
        }
        message = message ?? form.message;
        Form.set(form.data);
        Message.set(message);
        Empty.set(form.empty);
        Valid.set(form.valid);
        Errors.set(form.errors);
        Meta.set(form.meta);
        FormId.set(form.id);
        if (options.flashMessage && shouldSyncFlash(options)) {
            const flash = options.flashMessage.module.getFlash(page);
            if (message && get(flash) === undefined) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                flash.set(message);
            }
        }
    }
    async function _update(form, untaint) {
        let cancelled = false;
        const data = {
            form,
            cancel: () => (cancelled = true)
        };
        for (const event of formEvents.onUpdate) {
            await event(data);
        }
        if (cancelled) {
            if (options.flashMessage)
                cancelFlash(options);
            return;
        }
        if (form.valid &&
            options.resetForm &&
            (options.resetForm === true || (await options.resetForm()))) {
            _resetForm(form.message);
        }
        else {
            rebind(form, untaint);
        }
        // onUpdated may check stores, so need to wait for them to update.
        if (formEvents.onUpdated.length) {
            await tick();
        }
        // But do not await on onUpdated itself, since we're already finished with the request
        for (const event of formEvents.onUpdated) {
            event({ form });
        }
    }
    function _resetForm(message) {
        rebind(clone(initialForm), true, message);
    }
    const Form_update = async (result, untaint) => {
        if (result.type == 'error') {
            throw new SuperFormError(`ActionResult of type "${result.type}" cannot be passed to update function.`);
        }
        // All we need to do if redirected is to reset the form.
        // No events should be triggered because technically we're somewhere else.
        if (result.type == 'redirect') {
            if (options.resetForm &&
                (options.resetForm === true || (await options.resetForm()))) {
                _resetForm();
            }
            return;
        }
        if (typeof result.data !== 'object') {
            throw new SuperFormError('Non-object validation data returned from ActionResult.');
        }
        const forms = findForms(result.data);
        if (!forms.length) {
            throw new SuperFormError('No form data returned from ActionResult. Make sure you return { form } in the form actions.');
        }
        for (const newForm of forms) {
            if (newForm.id !== formId)
                continue;
            await _update(newForm, untaint ?? (result.status >= 200 && result.status < 300));
        }
    };
    const formEvents = {
        onSubmit: options.onSubmit ? [options.onSubmit] : [],
        onResult: options.onResult ? [options.onResult] : [],
        onUpdate: options.onUpdate ? [options.onUpdate] : [],
        onUpdated: options.onUpdated ? [options.onUpdated] : [],
        onError: options.onError ? [options.onError] : []
    };
    ///// When use:enhance is enabled ///////////////////////////////////////////
    // Prevent client validation on first page load
    // (when it recieives data from the server)
    function isTainted(obj) {
        if (obj === null)
            throw new SuperFormError('$tainted store contained null');
        if (typeof obj === 'object') {
            for (const obj2 of Object.values(obj)) {
                if (isTainted(obj2))
                    return true;
            }
        }
        return obj === true;
    }
    if (browser) {
        beforeNavigate((nav) => {
            if (options.taintedMessage && !get(Submitting)) {
                const taintStatus = get(Tainted);
                if (taintStatus &&
                    isTainted(taintStatus) &&
                    !window.confirm(options.taintedMessage)) {
                    nav.cancel();
                }
            }
        });
        // Need to subscribe to catch page invalidation.
        if (options.applyAction) {
            unsubscriptions.push(page.subscribe(async (pageUpdate) => {
                function error(type) {
                    throw new SuperFormError(`No form data found in ${type}. Make sure you return { form } in form actions and load functions.`);
                }
                const untaint = pageUpdate.status >= 200 && pageUpdate.status < 300;
                if (pageUpdate.form && typeof pageUpdate.form === 'object') {
                    const forms = findForms(pageUpdate.form);
                    if (!forms.length)
                        error('$page.form (ActionData)');
                    for (const newForm of forms) {
                        //console.log('ðŸš€~ ActionData ~ newForm:', newForm.id);
                        if (newForm === form || newForm.id !== formId)
                            continue;
                        await _update(newForm, untaint);
                    }
                }
                else if (pageUpdate.data &&
                    typeof pageUpdate.data === 'object') {
                    const forms = findForms(pageUpdate.data);
                    // It's a page reload, redirect or error/failure,
                    // so don't trigger any events, just update the data.
                    for (const newForm of forms) {
                        //console.log('ðŸš€ ~ PageData ~ newForm:', newForm.id);
                        if (newForm === form || newForm.id !== formId)
                            continue;
                        rebind(newForm, untaint);
                    }
                }
            }));
        }
    }
    const Fields = Object.fromEntries(Object.keys(initialForm.data).map((key) => {
        return [key, Fields_create(key, initialForm)];
    }));
    function Fields_create(key, validation) {
        return {
            name: key,
            value: fieldProxy(Form, key),
            errors: fieldProxy(Errors, key),
            constraints: fieldProxy(Constraints, key),
            type: validation.meta?.types[key]
        };
    }
    return {
        form: Form,
        formId: FormId,
        errors: Errors,
        message: Message,
        constraints: Constraints,
        meta: derived(Meta, ($m) => $m),
        fields: Fields,
        tainted: Tainted,
        valid: derived(Valid, ($s) => $s),
        empty: derived(Empty, ($e) => $e),
        submitting: derived(Submitting, ($s) => $s),
        delayed: derived(Delayed, ($d) => $d),
        timeout: derived(Timeout, ($t) => $t),
        options,
        capture: () => ({
            valid: get(Valid),
            errors: get(Errors),
            data: get(Form),
            empty: get(Empty),
            constraints: get(Constraints),
            message: get(Message),
            id: formId,
            meta: get(Meta),
            tainted: get(Tainted)
        }),
        restore: (snapshot) => {
            rebind(snapshot, snapshot.tainted ?? true);
        },
        validate: (path, opts) => {
            return validateField((Array.isArray(path) ? path : [path]), options.validators, options.defaultValidator, Form, Errors, opts);
        },
        enhance: (el, events) => {
            if (events) {
                if (events.onError) {
                    if (options.onError === 'apply') {
                        throw new SuperFormError('options.onError is set to "apply", cannot add any onError events.');
                    }
                    else if (events.onError === 'apply') {
                        throw new SuperFormError('Cannot add "apply" as onError event in use:enhance.');
                    }
                    formEvents.onError.push(events.onError);
                }
                if (events.onResult)
                    formEvents.onResult.push(events.onResult);
                if (events.onSubmit)
                    formEvents.onSubmit.push(events.onSubmit);
                if (events.onUpdate)
                    formEvents.onUpdate.push(events.onUpdate);
                if (events.onUpdated)
                    formEvents.onUpdated.push(events.onUpdated);
            }
            return formEnhance(el, Submitting, Delayed, Timeout, Errors, Form_update, options, Form, Message, enableTaintedMessage, formEvents, FormId, Meta, Constraints, Tainted, LastChanges);
        },
        firstError: FirstError,
        allErrors: AllErrors,
        reset: (options) => _resetForm(options?.keepMessage ? get(Message) : undefined)
    };
}
function cancelFlash(options) {
    if (!options.flashMessage || !browser)
        return;
    if (!shouldSyncFlash(options))
        return;
    document.cookie = `flash=; Max-Age=0; Path=${options.flashMessage.cookiePath ?? '/'};`;
}
function shouldSyncFlash(options) {
    if (!options.flashMessage || !browser)
        return false;
    return options.syncFlashMessage;
}
async function validateField(path, validators, defaultValidator, data, errors, options = {}) {
    if (options.update === undefined)
        options.update = true;
    if (options.taint === undefined)
        options.taint = false;
    function setError(errorMsgs) {
        if (typeof errorMsgs === 'string')
            errorMsgs = [errorMsgs];
        if (options.update === true || options.update == 'errors') {
            errors.update((errors) => {
                const error = traversePath(errors, path, (node) => {
                    if (node.value === undefined) {
                        node.parent[node.key] = {};
                        return node.parent[node.key];
                    }
                    else {
                        return node.value;
                    }
                });
                if (!error)
                    throw new SuperFormError('Error path could not be created: ' + path);
                error.parent[error.key] = errorMsgs ?? undefined;
                return errors;
            });
        }
        return errorMsgs ?? undefined;
    }
    async function defaultValidate() {
        if (defaultValidator == 'clear') {
            setError(undefined);
        }
        return undefined;
    }
    let value = options.value;
    const currentData = get(data);
    if (!('value' in options)) {
        const dataToValidate = traversePath(currentData, path);
        if (!dataToValidate) {
            throw new SuperFormError('Validation data not found: ' + path);
        }
        value = dataToValidate.value;
    }
    else if (options.update === true || options.update === 'value') {
        data.update(($data) => {
            setPaths($data, [path], value);
            return $data;
        }, { taint: options.taint });
    }
    //console.log('ðŸš€ ~ file: index.ts:871 ~ validate:', path, value);
    if (typeof validators !== 'object') {
        return defaultValidate();
    }
    // Remove array indices, they don't exist in validators.
    const validationPath = path.filter((p) => isNaN(parseInt(p)));
    function extractValidator(data, key) {
        const objectShape = data?._def?.schema?.shape;
        if (objectShape)
            return objectShape[key];
        const arrayShape = data?.element?.shape;
        if (arrayShape)
            return arrayShape[key];
        throw new SuperFormError('Invalid Zod validator for ' + key + ': ' + data);
    }
    if ('safeParseAsync' in validators) {
        // Zod validator
        const validator = traversePath(validators, validationPath, (data) => {
            return extractValidator(data.parent, data.key);
        });
        if (!validator)
            throw new SuperFormError('No Zod validator found: ' + path);
        const result = await extractValidator(validator.parent, validator.key).safeParseAsync(value);
        if (!result.success) {
            const msgs = mapErrors(result.error.format());
            return setError(options.errors ?? msgs._errors);
        }
        else {
            return setError(undefined);
        }
    }
    else {
        // SuperForms validator
        const validationPath = path.filter((p) => isNaN(parseInt(p)));
        const validator = traversePath(validators, validationPath);
        if (!validator) {
            // Path didn't exist
            throw new SuperFormError('No Superforms validator found: ' + path);
        }
        else if (validator.value === undefined) {
            // No validator, use default
            return defaultValidate();
        }
        else {
            const result = validator.value(value);
            return setError(result ? options.errors ?? result : result);
        }
    }
}
/**
 * Custom use:enhance version. Flash message support, friendly error messages, for usage with initializeForm.
 * @param formEl Form element from the use:formEnhance default parameter.
 */
function formEnhance(formEl, submitting, delayed, timeout, errs, Data_update, options, data, message, enableTaintedForm, formEvents, id, meta, constraints, tainted, lastChanges) {
    // Now we know that we are upgraded, so we can enable the tainted form option.
    enableTaintedForm();
    // Using this type in the function argument causes a type recursion error.
    const errors = errs;
    function equal(one, other) {
        return (one.map((v) => v.join()).join() == other.map((v) => v.join()).join());
    }
    // Add blur event, to check tainted
    let lastBlur = [];
    function checkBlur() {
        if (options.validationMethod == 'oninput' ||
            options.validationMethod == 'submit-only') {
            return;
        }
        const newChanges = get(lastChanges);
        if (options.validationMethod != 'onblur' &&
            equal(newChanges, lastBlur)) {
            return;
        }
        lastBlur = newChanges;
        for (const change of newChanges) {
            //console.log('ðŸš€ ~ file: index.ts:905 ~ BLUR:', change);
            validateField(change, options.validators, options.defaultValidator, data, errors);
        }
    }
    formEl.addEventListener('focusout', checkBlur);
    // Add input event, to check tainted
    function checkInput() {
        if (options.validationMethod == 'onblur' ||
            options.validationMethod == 'submit-only') {
            return;
        }
        const errorContent = get(errors);
        const taintedContent = get(tainted);
        for (const change of get(lastChanges)) {
            let shouldValidate = options.validationMethod === 'oninput';
            if (!shouldValidate) {
                const isTainted = taintedContent &&
                    pathExists(taintedContent, change, (value) => value === true);
                const errorNode = errorContent
                    ? pathExists(errorContent, change)
                    : undefined;
                // Need a special check here, since if the error has never existed,
                // there won't be a key for the error. But if it existed and was cleared,
                // the key exists with the value undefined.
                const hasError = errorNode && errorNode.key in errorNode.parent;
                shouldValidate = !!isTainted && !!hasError;
            }
            if (shouldValidate) {
                //console.log('ðŸš€ ~ file: index.ts:920 ~ INPUT with error:', change);
                validateField(change, options.validators, options.defaultValidator, data, errors);
            }
        }
    }
    formEl.addEventListener('input', checkInput);
    const ErrorTextEvents = new Set();
    function ErrorTextEvents_selectText(e) {
        const target = e.target;
        if (options.selectErrorText)
            target.select();
    }
    function ErrorTextEvents_addErrorTextListeners(formEl) {
        formEl.querySelectorAll('input').forEach((el) => {
            el.addEventListener('invalid', ErrorTextEvents_selectText);
        });
    }
    function ErrorTextEvents_removeErrorTextListeners(formEl) {
        formEl
            .querySelectorAll('input')
            .forEach((el) => el.removeEventListener('invalid', ErrorTextEvents_selectText));
    }
    onDestroy(() => {
        ErrorTextEvents.forEach((formEl) => ErrorTextEvents_removeErrorTextListeners(formEl));
        ErrorTextEvents.clear();
        formEl.removeEventListener('focusout', checkBlur);
        formEl.removeEventListener('input', checkInput);
    });
    /**
     * @DCI-context
     */
    function Form(formEl) {
        function rebind() {
            if (options.selectErrorText) {
                if (Form && formEl !== Form) {
                    ErrorTextEvents_removeErrorTextListeners(Form);
                    ErrorTextEvents.delete(Form);
                }
                if (!ErrorTextEvents.has(formEl)) {
                    ErrorTextEvents_addErrorTextListeners(formEl);
                    ErrorTextEvents.add(formEl);
                }
            }
            Form = formEl;
        }
        let Form;
        function Form_shouldAutoFocus(userAgent) {
            if (typeof options.autoFocusOnError === 'boolean')
                return options.autoFocusOnError;
            else
                return !/iPhone|iPad|iPod|Android/i.test(userAgent);
        }
        const Form_scrollToFirstError = async () => {
            if (options.scrollToError == 'off')
                return;
            const selector = options.errorSelector;
            if (!selector)
                return;
            // Wait for form to update with errors
            await tick();
            // Scroll to first form message, if not visible
            let el;
            el = Form.querySelector(selector);
            if (!el)
                return;
            // Find underlying element if it is a FormGroup element
            el = el.querySelector(selector) ?? el;
            const nav = options.stickyNavbar
                ? document.querySelector(options.stickyNavbar)
                : null;
            if (!isElementInViewport(el, nav?.offsetHeight ?? 0)) {
                scrollToAndCenter(el, undefined, options.scrollToError);
            }
            // Don't focus on the element if on mobile, it will open the keyboard
            // and probably hide the error message.
            if (!Form_shouldAutoFocus(navigator.userAgent))
                return;
            let focusEl;
            focusEl = el;
            if (!['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA'].includes(focusEl.tagName)) {
                focusEl = focusEl.querySelector('input:not([type="hidden"]):not(.flatpickr-input), select, textarea');
            }
            if (focusEl) {
                try {
                    focusEl.focus({ preventScroll: true });
                    if (options.selectErrorText && focusEl.tagName == 'INPUT') {
                        focusEl.select();
                    }
                }
                catch (err) {
                    // Some hidden inputs like from flatpickr cannot be focused.
                }
            }
        };
        rebind();
        {
            let state = FetchStatus.Idle;
            let delayedTimeout, timeoutTimeout;
            const setState = (s) => {
                state = s;
                submitting.set(state >= FetchStatus.Submitting);
                delayed.set(state >= FetchStatus.Delayed);
                timeout.set(state >= FetchStatus.Timeout);
            };
            return {
                submitting: () => {
                    rebind();
                    setState(state != FetchStatus.Delayed
                        ? FetchStatus.Submitting
                        : FetchStatus.Delayed);
                    // https://www.nngroup.com/articles/response-times-3-important-limits/
                    if (delayedTimeout)
                        clearTimeout(delayedTimeout);
                    if (timeoutTimeout)
                        clearTimeout(timeoutTimeout);
                    delayedTimeout = window.setTimeout(() => {
                        if (state == FetchStatus.Submitting)
                            setState(FetchStatus.Delayed);
                    }, options.delayMs);
                    timeoutTimeout = window.setTimeout(() => {
                        if (state == FetchStatus.Delayed)
                            setState(FetchStatus.Timeout);
                    }, options.timeoutMs);
                },
                completed: (cancelled) => {
                    if (delayedTimeout)
                        clearTimeout(delayedTimeout);
                    if (timeoutTimeout)
                        clearTimeout(timeoutTimeout);
                    delayedTimeout = timeoutTimeout = 0;
                    setState(FetchStatus.Idle);
                    if (!cancelled)
                        setTimeout(Form_scrollToFirstError);
                },
                scrollToFirstError: () => setTimeout(Form_scrollToFirstError),
                isSubmitting: () => state === FetchStatus.Submitting || state === FetchStatus.Delayed
            };
        }
    }
    const htmlForm = Form(formEl);
    let currentRequest;
    return enhance(formEl, async (submit) => {
        let cancelled = false;
        function cancel() {
            cancelled = true;
            return submit.cancel();
        }
        if (htmlForm.isSubmitting() && options.multipleSubmits == 'prevent') {
            cancel();
        }
        else {
            if (htmlForm.isSubmitting() && options.multipleSubmits == 'abort') {
                if (currentRequest)
                    currentRequest.abort();
            }
            currentRequest = submit.controller;
            const data = { ...submit, cancel };
            for (const event of formEvents.onSubmit) {
                await event(data);
            }
        }
        if (cancelled) {
            if (options.flashMessage)
                cancelFlash(options);
        }
        else {
            // Client validation
            if (options.validators) {
                const checkData = get(data);
                let valid;
                let clientErrors = {};
                if ('safeParseAsync' in options.validators) {
                    // Zod validator
                    const validator = options.validators;
                    const result = await validator.safeParseAsync(checkData);
                    valid = result.success;
                    if (!result.success) {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        clientErrors = mapErrors(result.error.format());
                    }
                }
                else {
                    // SuperForms validator
                    valid = true;
                    const validator = options.validators;
                    const newErrors = [];
                    await traversePathsAsync(checkData, async ({ value, path }) => {
                        // Filter out array indices, the validator structure doesn't contain these.
                        const validationPath = path.filter((p) => isNaN(parseInt(p)));
                        const maybeValidator = traversePath(validator, validationPath);
                        if (typeof maybeValidator?.value === 'function') {
                            const check = maybeValidator.value;
                            if (Array.isArray(value)) {
                                for (const key in value) {
                                    const errors = await check(value[key]);
                                    if (errors) {
                                        valid = false;
                                        newErrors.push({
                                            path: path.concat([key]),
                                            errors: typeof errors === 'string'
                                                ? [errors]
                                                : errors ?? undefined
                                        });
                                    }
                                }
                            }
                            else {
                                const errors = await check(value);
                                if (errors) {
                                    valid = false;
                                    newErrors.push({
                                        path,
                                        errors: typeof errors === 'string'
                                            ? [errors]
                                            : errors ?? undefined
                                    });
                                }
                            }
                        }
                    });
                    for (const { path, errors } of newErrors) {
                        const errorPath = traversePath(clientErrors, path, ({ parent, key, value }) => {
                            if (value === undefined)
                                parent[key] = {};
                            return parent[key];
                        });
                        if (errorPath) {
                            const { parent, key } = errorPath;
                            parent[key] = errors;
                        }
                    }
                }
                if (!valid) {
                    cancel();
                    const validationResult = {
                        valid,
                        errors: clientErrors,
                        data: checkData,
                        empty: false,
                        constraints: get(constraints),
                        message: undefined,
                        id: get(id),
                        meta: get(meta)
                    };
                    const result = {
                        type: 'failure',
                        status: (typeof options.SPA === 'boolean'
                            ? undefined
                            : options.SPA?.failStatus) ?? 400,
                        data: { form: validationResult }
                    };
                    setTimeout(() => validationResponse({ result }), 0);
                }
            }
            if (!cancelled) {
                switch (options.clearOnSubmit) {
                    case 'errors-and-message':
                        errors.set({});
                        message.set(undefined);
                        break;
                    case 'errors':
                        errors.set({});
                        break;
                    case 'message':
                        message.set(undefined);
                        break;
                }
                if (options.flashMessage &&
                    (options.clearOnSubmit == 'errors-and-message' ||
                        options.clearOnSubmit == 'message') &&
                    shouldSyncFlash(options)) {
                    options.flashMessage.module.getFlash(page).set(undefined);
                }
                htmlForm.submitting();
                if (options.SPA) {
                    cancel();
                    const validationResult = {
                        valid: true,
                        errors: {},
                        data: get(data),
                        empty: false,
                        constraints: get(constraints),
                        message: undefined,
                        id: get(id),
                        meta: get(meta)
                    };
                    const result = {
                        type: 'success',
                        status: 200,
                        data: { form: validationResult }
                    };
                    setTimeout(() => validationResponse({ result }), 0);
                }
                else if (options.dataType === 'json') {
                    const postData = get(data);
                    const chunks = chunkSubstr(stringify(postData), 500000);
                    for (const chunk of chunks) {
                        submit.data.append('__superform_json', chunk);
                    }
                    // Clear post data to reduce transfer size,
                    // since $form should be serialized and sent as json.
                    Object.keys(postData).forEach((key) => {
                        // Files should be kept though, even if same key.
                        if (typeof submit.data.get(key) === 'string') {
                            submit.data.delete(key);
                        }
                    });
                }
            }
        }
        // Thanks to https://stackoverflow.com/a/29202760/70894
        function chunkSubstr(str, size) {
            const numChunks = Math.ceil(str.length / size);
            const chunks = new Array(numChunks);
            for (let i = 0, o = 0; i < numChunks; ++i, o += size) {
                chunks[i] = str.substring(o, o + size);
            }
            return chunks;
        }
        async function validationResponse(event) {
            const result = event.result;
            currentRequest = null;
            let cancelled = false;
            const data = {
                result,
                formEl,
                cancel: () => (cancelled = true)
            };
            for (const event of formEvents.onResult) {
                await event(data);
            }
            if (!cancelled) {
                if (result.type !== 'error') {
                    if (result.type === 'success' && options.invalidateAll) {
                        await invalidateAll();
                    }
                    if (options.applyAction) {
                        // This will trigger the page subscription in superForm,
                        // which will in turn call Data_update.
                        await applyAction(result);
                    }
                    else {
                        // Call Data_update directly to trigger events
                        await Data_update(result);
                    }
                }
                else {
                    // Error result
                    if (options.applyAction) {
                        if (options.onError == 'apply') {
                            await applyAction(result);
                        }
                        else {
                            // Transform to failure, to avoid data loss
                            await applyAction({
                                type: 'failure',
                                status: Math.floor(result.status || 500)
                            });
                        }
                    }
                    // Check if the error message should be replaced
                    if (options.onError !== 'apply') {
                        // TODO: Omit 'apply' and undefined from the type
                        // They are already filtered out, but type shouldn't be any.
                        const data = { result, message };
                        for (const event of formEvents.onError) {
                            if (event !== 'apply')
                                await event(data);
                        }
                    }
                }
                // Set flash message, which should be set in all cases, even
                // if we have redirected (which is the point of the flash message!)
                if (options.flashMessage) {
                    if (result.type == 'error' && options.flashMessage.onError) {
                        await options.flashMessage.onError({
                            result,
                            message: options.flashMessage.module.getFlash(page)
                        });
                    }
                    else if (result.type != 'error') {
                        await options.flashMessage.module.updateFlash(page);
                    }
                }
            }
            else {
                // Cancelled
                if (options.flashMessage)
                    cancelFlash(options);
            }
            htmlForm.completed(cancelled);
        }
        return validationResponse;
    });
}
