import { type InputConstraints } from './index.js';
import type { ZodTypeInfo } from './entity.js';
import { z, type ZodTypeAny, type AnyZodObject, ZodDefault, ZodNullable, ZodOptional, ZodEffects } from 'zod';
export type UnwrappedEntity<T> = T extends ZodOptional<infer U> ? UnwrappedEntity<U> : T extends ZodDefault<infer U> ? UnwrappedEntity<U> : T extends ZodNullable<infer U> ? UnwrappedEntity<U> : T extends ZodEffects<infer U> ? UnwrappedEntity<U> : T;
type EntityRecord<T extends AnyZodObject, K> = Record<keyof z.infer<T>, K>;
export type EntityMetaData<T extends AnyZodObject> = {
    types: EntityRecord<T, string>;
};
export type Entity<T extends AnyZodObject> = {
    typeInfo: EntityRecord<T, ZodTypeInfo>;
    defaultEntity: z.infer<T>;
    constraints: InputConstraints<T>;
    meta: EntityMetaData<T>;
    hash: string;
    keys: string[];
};
export declare function unwrapZodType(zodType: ZodTypeAny): ZodTypeInfo;
export declare function entityHash<T extends AnyZodObject>(meta: EntityMetaData<T>): string;
export declare function entityData<T extends AnyZodObject>(schema: T): Entity<T>;
export declare function valueOrDefault(value: unknown, strict: boolean, implicitDefaults: true, schemaInfo: ZodTypeInfo): any;
/**
 * Returns the default values for a zod validation schema.
 * The main gotcha is that undefined values are changed to null if the field is nullable.
 */
export declare function defaultData<T extends AnyZodObject>(schema: T): z.infer<T>;
export {};
