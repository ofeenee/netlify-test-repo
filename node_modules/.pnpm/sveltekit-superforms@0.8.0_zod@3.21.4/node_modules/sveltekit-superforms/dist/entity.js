export function mapErrors(obj, top = true) {
    const output = {};
    const entries = Object.entries(obj);
    if (entries.length === 1 &&
        entries[0][0] === '_errors' &&
        obj._errors.length) {
        return (top ? obj : obj._errors);
    }
    else if (obj._errors.length) {
        output._errors = obj._errors;
    }
    for (const [key, value] of entries.filter(([key]) => key !== '_errors')) {
        // _errors are filtered out, so casting is fine
        output[key] = mapErrors(value, false);
    }
    return output;
}
export function findErrors(errors, path = []) {
    const entries = Object.entries(errors);
    return entries.flatMap(([key, value]) => {
        if (Array.isArray(value) && value.length > 0) {
            const currPath = path.concat([key]);
            return value.map((message) => ({ path: currPath, message }));
        }
        else {
            return findErrors(errors[key], path.concat([key]));
        }
    });
}
export async function traversePathAsync(obj, path, modifier) {
    if (!path.length)
        return undefined;
    path = [...path];
    let parent = obj;
    while (path.length > 1) {
        const key = path[0];
        const value = modifier
            ? await modifier({
                parent,
                key: String(key),
                value: parent[key]
            })
            : parent[key];
        if (value === undefined)
            return undefined;
        else
            parent = value; // TODO: Handle non-object values
        path.shift();
    }
    const key = path[0];
    return {
        parent,
        key: String(key),
        value: parent[key]
    };
}
export function pathExists(obj, path, value) {
    const exists = traversePath(obj, path);
    if (!exists)
        return undefined;
    if (value === undefined)
        return exists;
    return value(exists.value) ? exists : undefined;
}
export function traversePath(obj, path, modifier) {
    if (!path.length)
        return undefined;
    path = [...path];
    let parent = obj;
    while (path.length > 1) {
        const key = path[0];
        const value = modifier
            ? modifier({
                parent,
                key: String(key),
                value: parent[key]
            })
            : parent[key];
        if (value === undefined)
            return undefined;
        else
            parent = value; // TODO: Handle non-object values
        path.shift();
    }
    const key = path[0];
    return {
        parent,
        key: String(key),
        value: parent[key]
    };
}
export function traversePaths(parent, modifier, path = []) {
    for (const key in parent) {
        const value = parent[key];
        const isLeaf = value === null || typeof value !== 'object';
        const pathData = {
            parent,
            key,
            value,
            path: path.map(String).concat([key]),
            isLeaf
        };
        const status = modifier(pathData);
        if (status === 'abort')
            return status;
        else if (status === 'skip')
            break;
        else if (!isLeaf) {
            const status = traversePaths(value, modifier, pathData.path);
            if (status === 'abort')
                return status;
        }
    }
}
export async function traversePathsAsync(parent, modifier, path = []) {
    for (const key in parent) {
        const value = parent[key];
        const isLeaf = value === null || typeof value !== 'object';
        const pathData = {
            parent,
            key,
            value,
            path: path.map(String).concat([key]),
            isLeaf
        };
        const status = await modifier(pathData);
        if (status === 'abort')
            return status;
        else if (status === 'skip')
            break;
        else if (!isLeaf) {
            const status = traversePaths(value, modifier, pathData.path);
            if (status === 'abort')
                return status;
        }
    }
}
/**
 * Compare two objects and return the differences as paths.
 */
export function comparePaths(newObj, oldObj) {
    const diffPaths = new Map();
    function checkPath(data, compareTo) {
        if (data.isLeaf) {
            const exists = traversePath(compareTo, data.path);
            /*
            console.log('----------- Compare ------------ ');
            console.log(data);
            console.log('with');
            console.log(exists);
            */
            if (!exists) {
                diffPaths.set(data.path.join(' '), data.path);
            }
            else if (data.value instanceof Date &&
                exists.value instanceof Date &&
                data.value.getTime() != exists.value.getTime()) {
                diffPaths.set(data.path.join(' '), data.path);
            }
            else if (data.value !== exists.value) {
                diffPaths.set(data.path.join(' '), data.path);
            }
        }
    }
    traversePaths(newObj, (data) => checkPath(data, oldObj));
    traversePaths(oldObj, (data) => checkPath(data, newObj));
    return Array.from(diffPaths.values());
}
export function setPaths(obj, paths, value) {
    for (const path of paths) {
        const leaf = traversePath(obj, path, ({ parent, key, value }) => {
            if (value === undefined || typeof value !== 'object') {
                // If a previous check tainted the node, but the search goes deeper,
                // so it needs to be replaced with a (parent) node
                parent[key] = {};
            }
            return parent[key];
        });
        if (leaf)
            leaf.parent[leaf.key] = value;
    }
}
