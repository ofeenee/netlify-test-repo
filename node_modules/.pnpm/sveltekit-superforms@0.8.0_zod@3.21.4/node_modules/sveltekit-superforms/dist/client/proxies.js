import { derived } from 'svelte/store';
import { stringify, parse } from 'devalue';
import { SuperFormError } from '../index.js';
import { traversePath } from '../entity.js';
const defaultOptions = {
    trueStringValue: 'true',
    dateFormat: 'iso'
};
export function intProxy(form, path) {
    return stringProxy(form, path, 'int', defaultOptions);
}
export function booleanProxy(form, path, options = {
    trueStringValue: 'true'
}) {
    return stringProxy(form, path, 'boolean', {
        ...defaultOptions,
        ...options
    });
}
export function numberProxy(form, path) {
    return stringProxy(form, path, 'number', defaultOptions);
}
export function dateProxy(form, path, options = {
    format: 'iso'
}) {
    return stringProxy(form, path, 'date', {
        ...defaultOptions,
        dateFormat: options.format
    });
}
/**
 * Creates a string store that will pass its value to a field in the form.
 * @param form The form
 * @param field Form field
 * @param type 'number' | 'int' | 'boolean'
 */
function stringProxy(form, path, type, options) {
    function toValue(val) {
        if (typeof val !== 'string')
            throw new SuperFormError('stringProxy received a non-string value.');
        if (type == 'number')
            return parseFloat(val);
        if (type == 'int')
            return parseInt(val, 10);
        if (type == 'boolean')
            return !!val;
        else {
            // date
            return new Date(val);
        }
    }
    const proxy2 = fieldProxy(form, path);
    const proxy = derived(proxy2, (value) => {
        if (value === undefined || value === null)
            return '';
        if (type == 'int' || type == 'number') {
            const num = value;
            return isNaN(num) ? '' : String(num);
        }
        else if (type == 'date') {
            const date = value;
            if (isNaN(date))
                return '';
            switch (options.dateFormat) {
                case 'iso':
                    return date.toISOString();
                case 'date':
                    return date.toISOString().slice(0, 10);
                case 'datetime':
                    return date.toISOString().slice(0, 16);
                case 'time':
                    return date.toISOString().slice(11, 16);
                case 'date-utc':
                    return UTCDate(date);
                case 'datetime-utc':
                    return UTCDate(date) + 'T' + UTCTime(date);
                case 'time-utc':
                    return UTCTime(date);
                case 'date-local':
                    return localDate(date);
                case 'datetime-local':
                    return localDate(date) + 'T' + localTime(date);
                case 'time-local':
                    return localTime(date);
            }
        }
        else {
            // boolean
            return value ? options.trueStringValue : '';
        }
    });
    return {
        subscribe: proxy.subscribe,
        set(val) {
            proxy2.set(toValue(val));
            //form.update((f) => ({ ...f, [field as any]: toValue(val) }));
        },
        update(updater) {
            proxy2.update((f) => toValue(updater(String(f))));
            /*
            form.update((f) => ({
              ...f,
              [field as any]: toValue(updater(String(f[field as any])))
            }));
            */
        }
    };
}
export function jsonProxy(form, field) {
    function unserialize(val) {
        try {
            return parse(val);
        }
        catch {
            return undefined;
        }
    }
    const proxy = derived(form, ($form) => unserialize($form[field]));
    function update(updater) {
        form.update((f) => {
            return {
                ...f,
                [field]: stringify(updater(unserialize(f[field])))
            };
        });
    }
    return {
        subscribe: proxy.subscribe,
        update,
        set(val) {
            form.update((f) => ({ ...f, [field]: stringify(val) }));
        }
    };
}
function normalizePath(path) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (Array.isArray(path) ? path : [path]);
}
//type UnwrapPath<T extends object, P extends keyof T | FieldPath<T>> = P extends FieldPath<T> ? P : [Extract<P, keyof T>]
export function formFieldProxy(form, path) {
    const path2 = normalizePath(path);
    // Filter out array indices, the constraints structure doesn't contain these.
    const constraintsPath = path2.filter((p) => isNaN(parseInt(String(p))));
    return {
        path: path2,
        value: fieldProxy(form.form, path2),
        errors: fieldProxy(form.errors, path2),
        constraints: fieldProxy(form.constraints, constraintsPath)
    };
}
export function fieldProxy(form, path) {
    const path2 = normalizePath(path);
    const proxy = derived(form, ($form) => {
        const data = traversePath($form, path2);
        return data?.value;
    });
    return {
        subscribe(...params) {
            //console.log('~ fieldproxy ~ subscribe', path);
            const unsub = proxy.subscribe(...params);
            return () => {
                //console.log('~ fieldproxy ~ unsubscribe', field);
                unsub();
            };
        },
        //subscribe: proxy.subscribe,
        update(upd) {
            //console.log('~ fieldStore ~ update value for', path);
            form.update((f) => {
                const output = traversePath(f, path2);
                if (output)
                    output.parent[output.key] = upd(output.value);
                //else console.log('[update] Not found:', path, 'in', f);
                return f;
            });
        },
        set(value) {
            //console.log('~ fieldStore ~ set value for', path, value);
            form.update((f) => {
                const output = traversePath(f, path2);
                if (output)
                    output.parent[output.key] = value;
                //else console.log('[set] Not found:', path, 'in', f);
                return f;
            });
        }
    };
}
function localDate(date) {
    return (date.getFullYear() +
        '-' +
        String(date.getMonth() + 1).padStart(2, '0') +
        '-' +
        String(date.getDate()).padStart(2, '0'));
}
function localTime(date) {
    return (String(date.getHours()).padStart(2, '0') +
        ':' +
        String(date.getMinutes()).padStart(2, '0'));
}
function UTCDate(date) {
    return (date.getUTCFullYear() +
        '-' +
        String(date.getUTCMonth() + 1).padStart(2, '0') +
        '-' +
        String(date.getUTCDate()).padStart(2, '0'));
}
function UTCTime(date) {
    return (String(date.getUTCHours()).padStart(2, '0') +
        ':' +
        String(date.getUTCMinutes()).padStart(2, '0'));
}
/*
function dateToUTC(date: Date) {
  return new Date(
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds()
  );
}
*/
